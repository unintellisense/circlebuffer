export declare class CircularBuffer<T> {
    private length;
    private start;
    private end;
    private size;
    private data;
    overflow: null | ((T, CBuffer) => void);
    constructor(size: number, data?: T[]);
    pop(): T | undefined;
    push(args: T | T[] | undefined): number | undefined;
    reverse(): this;
    rotateLeft(cntr?: number): this;
    rotateRight(cntr?: number): this;
    shift(): T | undefined;
    sort(compareFn?: (a: T, b: T) => number): this;
    unshift(args: T | T[] | undefined): number;
    indexOf(arg: T, idx?: number): number;
    lastIndexOf(arg: T, idx?: number): number;
    sortedIndex(value: T, comparator?: (a: T, b: T) => number): number;
    every(callback: (val: T, idx?: number, buff?: CircularBuffer<T>) => boolean): boolean;
    forEach(callback: (val: T, idx?: number, buff?: CircularBuffer<T>) => void): void;
    some(callback: (val: T, idx?: number, buff?: CircularBuffer<T>) => boolean): boolean;
    avg(): number;
    sum(): number;
    median(): number;
    empty(): this;
    fill(arg: T): this;
    first(): T;
    last(): T;
    get(arg: number): T;
    isFull(): boolean;
    set(idx: number, arg: T): T;
    toArray(): T[];
    slice(start?: number, end?: number): T[];
}
